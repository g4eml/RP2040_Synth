//Chip specific functions for CMT2119A device


#define TWICLK 6         //GPO 6 Connect to CMT2119A  CLK Pin 
#define TWIDAT 7         //GPO 7 Connect to CMT2119A  DAT Pin

// A default register setting for a starting point. Generated by Official programming software. 
static const uint16_t CMT2119ook[21] =
{
0x007F,
0x5000,
0x0000,
0x0000,
0x0000,
0xF000,
0x0000,
0xBB13,
0x4200,
0x0000,
0x2401,
0x01B0,
0x8000,
0x0006,
0xFFFF,
0x0020,
0x5F1E,
0x22D6,
0x0E13,
0x0019,
0x2000,
};

void CMT2119ASetDefault(void)
{
  for(int i = 0;i<21;i++)
  {
    chanData[channel].reg[i] = CMT2119ook[i];
  }
  CMT2119ASetFrequency(0);
  CMT2119AUpdate();
}


void CMT2119AInit(void)
{
  int chip = CMT2119A;                  //index to the current chip type
  numberOfRegs = 21;                   //number of registers in the current chip type
  numberOfBits = 16;                   //number of bits in each register
  maxPfd = 0;                          //maximum PFD frequency
  minPfd = 0;
  maxOsc = 30;
  minOsc = 20;
  refOsc = 26.0;
  jt4Only = true;
  jtDisable = true;
  pinMode(TWICLK,OUTPUT);
  digitalWrite(TWICLK,HIGH); 
  pinMode(TWIDAT,OUTPUT);
  digitalWrite(TWIDAT,LOW); 
}


void CMT2119A_RESET(void)
{
  TWI_reset(); //step 1
  TWI_WRREG(0x3d, 0x01); //step 2 send SOFT_RST
  delay(2);
  TWI_WRREG(0x0D, 0x02); //step 7 send the TWI_OFF command. Control reverts to simple DAT signals
}



void CMT2119AUpdate(void)
{
TWI_reset(); //step 1
TWI_WRREG(0x3d, 0x01); //step 2 send SOFT_RST
delay(2);

//some proprietary command preamble from the datasheet
TWI_WRREG(0x02, 0x78); //Open LDO & Osc step 3

TWI_WRREG(0x2F, 0x80); //vActiveRegsister step 4
TWI_WRREG(0x35, 0xCA);
TWI_WRREG(0x36, 0xEB);
TWI_WRREG(0x37, 0x37);
TWI_WRREG(0x38, 0x82);

TWI_WRREG(0x12, 0x10); //vEnableRegMode step 5
TWI_WRREG(0x12, 0x00);
TWI_WRREG(0x24, 0x07);
TWI_WRREG(0x1D, 0x20);

//program the default RAM config by RFPDK generated setup
//TWI_RAM(chanData[channel].reg,21); //step 6

for(int i =0;i<21;i++)
 {
  TWI_RAM1(i,chanData[channel].reg[i]);
 }

TWI_WRREG(0x0D, 0x02); //step 7 send the TWI_OFF command. Control reverts to simple DAT signals

digitalWrite(TWIDAT,HIGH);                 //output on
delay(2);
}


void CMT2119AUpdateFreqOnly(uint16_t r7,uint16_t r8)
{
TWI_reset(); //step 1
delay(2);

TWI_RAM1(7,r7);       //just update the divider registers. 
TWI_RAM1(8,r8);

TWI_WRREG(0x0D, 0x02); //step 7 send the TWI_OFF command. Control reverts to simple DAT signals

digitalWrite(TWIDAT,HIGH);                 //output on
delay(2);
}


double CMT2119AGetPfd(void)
{
  double pfd = refOsc / 131072.0 ;
  return pfd;
}

void CMT2119ASetFrequency(double direct)
{
  bool freqOK = false;

  double freq;
  double pfd;
  uint8_t prescale15;
  uint8_t prescale2;
  double n;
  char resp;

  pfd = CMT2119AGetPfd();

  freqOK = false;
  if(direct ==0)
  {
   while(!freqOK)
    {
      if(chanData[channel].extMult > 1)
      {
      Serial.print("\nEnter Required Final Multiplied Frequency in MHz -->");
      freq = inputFloat() / (double) chanData[channel].extMult;
      }
      else
      {
      Serial.print("\nEnter Required Frequency in MHz -->");
      freq = inputFloat();        
      }
      if((freq > 150.0) && (freq <= 1297.0))
        {
          freqOK = true;
        }
      else
        {
          Serial.println("Synthesiser Frequency must be between 150 and 1297 MHz");
        }
    }
  }
  else
  {
    freq = direct;
  }

if(freq<=320.0)
	{
	prescale15=1;
	prescale2=1;
	}
else if(freq<=480.0)
	{
	prescale15=0;
	prescale2=1;
	}
else if(freq<=640.0)
        {
        prescale15=1;
        prescale2=0;
        }
else
	{
	prescale15=0;
        prescale2=0;
	}

if(prescale15) chanData[channel].reg[6] = 1; else chanData[channel].reg[6] = 0;
if(prescale2) chanData[channel].reg[1] = 0x5400; else chanData[channel].reg[1] = 0x5000;

if(prescale15) freq = freq * 1.5;
if(prescale2) freq = freq *2.0;

//frequency
uint32_t pll = round((freq/pfd)/2) *2;                //round to nearest even number
chanData[channel].reg[7] = pll & 0xfffe;              //lsb must always be zero. 
uint16_t pllh = (pll >> 8) & 0xFF00;
chanData[channel].reg[8] = pllh;
chanData[channel].reg[9] = 0;
}


void CMT2119ACalcFreq(void)
{
 uint8_t prescale15;
 uint8_t prescale2;
 uint32_t divider;
 double vco;
 double pfd;
 double fr;
 double diva;

 prescale15 = chanData[channel].reg[6] & 0x01;
 prescale2 = (chanData[channel].reg[1] & 0x0400) >> 10;
 divider = ((chanData[channel].reg[8] & 0xFF00) << 8) + chanData[channel].reg[7]; 
 pfd = CMT2119AGetPfd();

 vco = (double) divider * pfd;
 fr=vco;
 diva=1;
 if(prescale2) diva = diva * 2;
 if(prescale15) diva=diva * 1.5;
 

  Serial.println();
  Serial.print("Chip type is ");
  Serial.println(chipName[chip]);
  Serial.print("Reference Oscillator = ");
  Serial.print(refOsc,10);
  Serial.println(" MHz");
  Serial.print("Step Size = ");
  Serial.print(pfd*2000000,10);           //double the step size to allow for the fact the divider must be even. 
  Serial.println(" Hz");
  Serial.print("N = ");
  Serial.println(divider/2);              //halve the divider to allow for the fact it must be even. 

  Serial.print("VCO = ");
  Serial.print(vco , 10);
  Serial.println(" MHz");

  Serial.print("O/P Divider = ");
  Serial.println(diva,1);

  Serial.print("Output Frequency = ");
  Serial.print(vco / diva , 10);
  Serial.println(" MHz");

  if(chanData[channel].extMult > 1)
    {
      Serial.print("External Multipler = X");
      Serial.println(chanData[channel].extMult);
      Serial.print("Final Multiplied Frequency = ");
      Serial.print((vco / diva) * (double) chanData[channel].extMult, 10);
      Serial.println(" MHz"); 
    }
}

double CMT2119AGetFrequency(void)
{
 uint8_t prescale15;
 uint8_t prescale2;
 uint32_t divider;
 double vco;
 double pfd;
 double diva;

 prescale15 = chanData[channel].reg[6] & 0x01;
 prescale2 = (chanData[channel].reg[1] & 0x0400) >> 10;
 divider = ((chanData[channel].reg[8] & 0xFF00) << 8) + chanData[channel].reg[7]; 
 pfd = CMT2119AGetPfd();

 vco = (double) divider * pfd;
 diva=1;
 if(prescale2) diva = diva * 2;
 if(prescale15) diva=diva * 1.5;
 
 return vco/diva;
}

 void CMT2119AjtShift(uint8_t val)
{
   static uint8_t lastval;
  
  if(val == lastval) return;
  lastval = val;
   CMT2119AUpdateFreqOnly(jtN[val],jtNum[val]);
}

  void CMT2119AFskKey(bool key)
{
  static bool lastkey;
  
  if(key == lastkey) return;
  lastkey = key;

  if(key)
    {
      CMT2119AUpdateFreqOnly(chanData[channel].reg[7],chanData[channel].reg[8]);
    }
  else
    {
      CMT2119AUpdateFreqOnly(cwidKeyUpN,cwidKeyUpNum);
    }
}

  void CMT2119AExtKey(bool key)
{
if(key)
    {
      CMT2119AUpdateFreqOnly(chanData[channel].reg[7],chanData[channel].reg[8]);
    }
  else
    {
      CMT2119AUpdateFreqOnly(ExtKeyUpN,ExtKeyUpNum);
    }
}

void CMT2119ASaveFskShift(void)
{
  cwidKeyUpN = chanData[channel].reg[7];
  cwidKeyUpNum = chanData[channel].reg[8];
}

void CMT2119ASaveKeyShift(void)
{
  ExtKeyUpN = chanData[channel].reg[7];
  ExtKeyUpNum = chanData[channel].reg[8];
}

void CMT2119ASaveJt(uint8_t index)
{
  jtN[index] = chanData[channel].reg[7];
  jtNum[index] = chanData[channel].reg[8];
}



void TWI_reset(void)
{
digitalWrite(TWIDAT,LOW);
digitalWrite(TWICLK,HIGH);
delayMicroseconds(1);

for(uint8_t i=0; i<32; ++i)
	{
	  digitalWrite(TWICLK,LOW);
	  delayMicroseconds(1);
	  digitalWrite(TWICLK,HIGH);
    delayMicroseconds(1);	
	}
  TWI_WRREG(0x0d, 0x00); 
}


void TWI_Write(uint8_t x)
{
digitalWrite(TWICLK,HIGH);
digitalWrite(TWIDAT,LOW);
for(uint8_t i=0; i<8; ++i)
	{
	digitalWrite(TWICLK,HIGH);
	if(x & 0x80) digitalWrite(TWIDAT,HIGH); else digitalWrite(TWIDAT,LOW);
	delayMicroseconds(1);
  digitalWrite(TWICLK,LOW); 
	delayMicroseconds(1);
	x<<=1;
	}
	digitalWrite(TWICLK,HIGH);
  digitalWrite(TWIDAT,LOW);
}

uint8_t TWI_Read(void)
{
uint8_t r=0;
pinMode(TWIDAT,INPUT);
digitalWrite(TWICLK,HIGH);
for(uint8_t i=0; i<8; ++i)
	{
	digitalWrite(TWICLK,HIGH);
	delayMicroseconds(1);
	r<<=1;
	digitalWrite(TWICLK,LOW);
	delayMicroseconds(1);
	if(digitalRead(TWIDAT)) r|=1;
	}
digitalWrite(TWICLK,HIGH);
pinMode(TWIDAT,OUTPUT);
digitalWrite(TWIDAT,LOW);
return r;
}


void TWI_WRREG(uint8_t addr, uint8_t data)
{
TWI_Write(0x80|(addr&0x3f));
TWI_Write(data);
}

uint8_t TWI_RDREG(uint8_t addr)
{
TWI_Write(0xc0|(addr&0x3f));
return TWI_Read();
}


void TWI_RAM1(uint8_t addr, uint16_t data)
{
  TWI_WRREG(0x18,addr);
  TWI_WRREG(0x19,data&0xff);
  TWI_WRREG(0x1A,data>>8);
  TWI_WRREG(0x25, 0x01);
}

void TWI_RAM(const uint32_t *x, uint8_t n)
{
for(uint8_t i=0; i<n; ++i)
{
 TWI_RAM1(i,*x++);
}
}

void TWI_EEPROM_ERASE(uint8_t add)
{
  uint8_t resp;
  TWI_WRREG(0x17,add);          //Set the EEPROM Address
  TWI_WRREG(0x16,0x39);           //start the erase
  do                          //wait till the erase has completed
   {
    delay(1);
    resp = TWI_RDREG(0x1F);
   }
  while ((resp & 0x08) == 0); 
  TWI_WRREG(0x16,0x31);           //end the erase
}

void TWI_EEPROM_WRITE(uint8_t add, uint16_t dat)
{
  uint8_t resp;
  TWI_WRREG(0x17,add);          //Set the EEPROM Address
  TWI_WRREG(0x19,dat & 0xFF);   //Set the EEPROM Low Byte
  TWI_WRREG(0x1A,dat >> 8);     //Set the EEPROM High Byte 
  TWI_WRREG(0x16,0x35);         //start the write
  do                            //wait till the erase has completed
   {
    delay(1);
    resp = TWI_RDREG(0x1F);
   }
  while ((resp & 0x08) == 0); 
  TWI_WRREG(0x16,0x31);           //end the write
}

uint16_t TWI_EEPROM_READ(uint8_t add)
{
  uint8_t resp;
  uint16_t val;
  TWI_WRREG(0x17,add);          //Set the EEPROM Address 
  TWI_WRREG(0x16,0x33);         //start the read
  do                            //wait till the erase has completed
   {
    delay(1);
    resp = TWI_RDREG(0x1F);
   }
  while ((resp & 0x08) == 0); 
  val =(TWI_RDREG(0x1C) <<8) + TWI_RDREG(0x1B) ;
  TWI_WRREG(0x16,0x31);           //end the read
  return val;
}

void TWI_EEPROM_SETUP(void)
{
    TWI_WRREG(0x02,0x3B);
    TWI_WRREG(0x2F,0x80);
    TWI_WRREG(0x3F,0x01);
    TWI_WRREG(0x16,0x31);
    TWI_WRREG(0x35,0xCA);
    TWI_WRREG(0x36,0xEB);
    TWI_WRREG(0x37,0x37);
    TWI_WRREG(0x38,0x82);        
}

void TWI_EEPROM_END(void)
{
    TWI_WRREG(0x16,0x30);
    TWI_WRREG(0x3F,0x00);
    TWI_WRREG(0x0C,0x27);
    TWI_WRREG(0x2F,0x00);
    TWI_WRREG(0x02,0x7F);
    TWI_WRREG(0x0C,0x00);
    TWI_WRREG(0x3D,0x01);         //SOFT_RESET.  
}

//Burn the Chips built in EEPROM. Sequence copied originally from official programmer and then trimmed. 

void CMT2119A_EEPROM_BURN(void)
{
  Serial.println("Burn and Verify Start");
  TWI_reset();
  TWI_reset();
  TWI_EEPROM_SETUP();
  for(int r=0;r<0x15;r++)           //erase and write EEPROM values 0x00 - 0x14 
   {
    TWI_EEPROM_ERASE(r);
    TWI_EEPROM_WRITE(r, chanData[channel].reg[r]);
   }

  for(int r=0;r<0x15;r++)           //verify the EEPROM values 0x00 - 0x14
   {
    uint16_t val = TWI_EEPROM_READ(r);
    if( val!= chanData[channel].reg[r])
     {
      Serial.print("Verify Error at address = ");
      Serial.print(r,HEX);
      Serial.print(" Value = ");
      Serial.println(val,HEX);
     }
   }
  TWI_EEPROM_END();
  Serial.println("Burn and Verify Complete");

  Serial.println("Resetting from CMT2119A EEPROM"); 
  CMT2119A_RESET();
  digitalWrite(TWIDAT,HIGH);
}